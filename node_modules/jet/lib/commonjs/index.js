"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionText = ConnectionText;
exports.JetContext = void 0;
exports.JetProvider = JetProvider;
exports.StatusEmoji = StatusEmoji;
exports.StatusText = StatusText;
exports.useJetContext = useJetContext;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _parseErrorStack = _interopRequireDefault(require("react-native/Libraries/Core/Devtools/parseErrorStack"));
var _symbolicateStackTrace = _interopRequireDefault(require("react-native/Libraries/Core/Devtools/symbolicateStackTrace"));
var _mochaRemoteClient = require("mocha-remote-client");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const JetContext = exports.JetContext = /*#__PURE__*/(0, _react.createContext)({
  connected: false,
  status: {
    kind: 'waiting'
  },
  config: {}
});
function isExternalFrame({
  file
}) {
  return !file.includes('/jet/') && !file.includes('/mocha-remote/packages/client/dist/') && !file.includes('/mocha-remote-client/dist/');
}
function framesToStack(error, frames) {
  const lines = frames.filter(isExternalFrame).map(({
    methodName,
    column,
    file,
    lineNumber
  }) => {
    return `    at ${methodName} (${file}:${lineNumber}:${column})`;
  });
  return `${error.name}: ${error.message}\n${lines.join('\n')}`;
}
function JetProvider(props) {
  const [isConnected, setConnected] = (0, _react.useState)(false);
  const [currentStatus, setStatus] = (0, _react.useState)({
    kind: 'waiting'
  });
  const [currentConfig, setConfig] = (0, _react.useState)({});
  (0, _react.useEffect)(() => {
    const client = new _mochaRemoteClient.Client({
      ...props,
      title: props.title ?? `Jet tests on ${_reactNative.Platform.OS}`,
      async transformFailure(_, err) {
        const stack = (0, _parseErrorStack.default)(err.stack);
        const symbolicated = await (0, _symbolicateStackTrace.default)(stack);
        err.stack = framesToStack(err, symbolicated.stack);
        return err;
      },
      tests(_config) {
        beforeEach('async-pause', () => {
          return new Promise(resolve => setImmediate(resolve));
        });
        after(async () => {
          if (_config.coverage) {
            const coverage = global.__coverage__ ?? {};
            const url = (props.url ?? 'ws://localhost:8090').replace('ws://', 'http://') + '/coverage';
            return fetch(url, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(coverage)
            });
          }
          return Promise.resolve();
        });
        props.tests(_config);
        setConfig(_config);
      }
    }).on('connection', () => {
      setConnected(true);
    }).on('disconnection', () => {
      setConnected(false);
    }).on('running', runner => {
      if (runner.total === 0) {
        setStatus({
          kind: 'ended',
          totalTests: 0,
          failures: 0
        });
      }
      let currentTestIndex = 0;
      runner.on('test', test => {
        setStatus({
          kind: 'running',
          currentTest: test.fullTitle(),
          currentTestIndex: currentTestIndex++,
          totalTests: runner.total,
          failures: runner.failures
        });
      }).on('end', () => {
        setStatus({
          kind: 'ended',
          totalTests: runner.total,
          failures: runner.failures
        });
      });
    });
    return () => {
      client.disconnect();
    };
  }, [setStatus, setConfig, setConnected]);
  return /*#__PURE__*/_react.default.createElement(JetContext.Provider, {
    value: {
      status: currentStatus,
      connected: isConnected,
      config: currentConfig
    }
  }, props.children);
}
function useJetContext() {
  return (0, _react.useContext)(JetContext);
}
function getStatusEmoji(status) {
  if (status.kind === 'running') {
    return '🏃';
  } else if (status.kind === 'waiting') {
    return '⏳';
  } else if (status.kind === 'ended' && status.totalTests === 0) {
    return '🤷';
  } else if (status.kind === 'ended' && status.failures > 0) {
    return '❌';
  } else if (status.kind === 'ended') {
    return '✅';
  } else {
    return null;
  }
}
function StatusEmoji(props) {
  const {
    status
  } = useJetContext();
  return /*#__PURE__*/_react.default.createElement(_reactNative.Text, props, getStatusEmoji(status));
}
function getStatusMessage(status) {
  if (status.kind === 'running') {
    return `[${status.currentTestIndex + 1} of ${status.totalTests}] ${status.currentTest}`;
  } else if (status.kind === 'waiting') {
    return 'Waiting for Jet to start tests...';
  } else if (status.kind === 'ended' && status.failures > 0) {
    return `${status.failures} tests failed!`;
  } else if (status.kind === 'ended') {
    return 'All tests succeeded!';
  } else {
    return null;
  }
}
function StatusText(props) {
  const {
    status
  } = useJetContext();
  return /*#__PURE__*/_react.default.createElement(_reactNative.Text, props, getStatusMessage(status));
}
function getConnectionMessage(connected) {
  if (connected) {
    return '🛜 Connected to Jet';
  } else {
    return '🔌 Disconnected from Jet';
  }
}
function ConnectionText(props) {
  const {
    connected
  } = useJetContext();
  return /*#__PURE__*/_react.default.createElement(_reactNative.Text, props, getConnectionMessage(connected));
}
//# sourceMappingURL=index.js.map