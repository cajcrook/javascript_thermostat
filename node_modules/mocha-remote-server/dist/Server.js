"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = exports.ClientError = void 0;
const mocha_1 = __importDefault(require("mocha"));
const ws_1 = __importStar(require("ws"));
const path_1 = __importDefault(require("path"));
const flatted_1 = __importDefault(require("flatted"));
const stats_collector_1 = require("./stats-collector");
const debug_1 = require("./debug");
const FakeRunner_1 = require("./FakeRunner");
const ServerEventEmitter_1 = require("./ServerEventEmitter");
const serialization_1 = require("./serialization");
const builtinReporters = mocha_1.default.reporters;
function createPromiseHandle() {
    let resolve = () => {
        throw new Error("Expected new Promise callback to be called synchronously");
    };
    const promise = new Promise(r => (resolve = r));
    return { promise, resolve };
}
/**
 * An error thrown by a connected client
 */
class ClientError extends Error {
    constructor(message, ws) {
        super(message);
        this.ws = ws;
    }
}
exports.ClientError = ClientError;
class Server extends ServerEventEmitter_1.ServerEventEmitter {
    static nextDebug() {
        return (0, debug_1.extend)(`Server[${Server.debugCounter++}]`);
    }
    constructor(config = {}, debug = Server.nextDebug()) {
        super(debug.extend("events"));
        this.stoppedPromiseHandle = createPromiseHandle();
        /** The options to send to the next connecting running client */
        this.clientOptions = {};
        this._listening = false;
        this.handleConnection = (ws, req) => {
            this.debug("Client connected");
            // Check that the protocol matches
            const expectedProtocol = `mocha-remote-${this.config.id}`;
            ws.on("close", (code, reason) => {
                this.emit("disconnection", ws, code, reason.toString());
            });
            // Signal that a client has connected
            this.emit("connection", ws, req);
            // Disconnect if the protocol mismatch
            if (ws.protocol !== expectedProtocol) {
                // Protocol mismatch - close the connection
                ws.close(1002, `Expected "${expectedProtocol}" protocol got "${ws.protocol}"`);
                return;
            }
            if (this.client) {
                this.debug("A client was already connected");
                this.client.removeAllListeners();
                this.client.close(1013 /* try again later */, "Got a connection from another client");
                delete this.client;
            }
            // Hang onto the client
            this.client = ws;
            this.client.on("message", this.handleMessage.bind(this, this.client));
            // If we already have a runner, it can run now that we have a client
            if (this.runner) {
                if (this.clientOptions) {
                    this.send({ action: "run", options: this.clientOptions });
                }
                else {
                    throw new Error("Internal error: Expected a clientOptions");
                }
            }
            else if (this.config.autoRun) {
                this.debug("Start running tests because a client connected");
                this.run(() => {
                    this.debug("Stopped running tests from connection");
                });
            }
        };
        this.handleMessage = (ws, message) => {
            try {
                const msg = (0, serialization_1.deserialize)(message);
                if (typeof msg.action !== "string") {
                    throw new Error("Expected message to have an action property");
                }
                this.debug(`Received a '${msg.action}' message: %o`, msg);
                if (msg.action === "event") {
                    if (this.runner) {
                        const args = msg.args || [];
                        this.runner.emit(msg.name, ...args);
                    }
                    else {
                        throw new Error("Received a message from the client, but server wasn't running");
                    }
                }
                else if (msg.action === "error") {
                    if (typeof msg.message !== "string") {
                        throw new Error("Expected 'error' action to have an error argument with a message");
                    }
                    const err = new ClientError(msg.message, ws);
                    this.emit("error", err);
                }
                else {
                    const { action } = msg;
                    throw new Error(`Unexpected action "${action}"`);
                }
            }
            catch (err) {
                if (err instanceof Error) {
                    this.emit("error", err);
                    this.send({ action: "error", message: err.message });
                }
                else {
                    throw err;
                }
            }
        };
        this.debug = debug;
        this.debug("Constructing a server");
        this.config = Object.assign(Object.assign({}, Server.DEFAULT_CONFIG), config);
        this.stopped = this.stoppedPromiseHandle.promise;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug(`Server is starting`);
            yield new Promise((resolve, reject) => {
                this.wss = new ws_1.WebSocketServer({
                    host: this.config.host,
                    port: this.config.port
                });
                // When a client connects
                this.wss.on("connection", this.handleConnection);
                // When the server starts listening
                this.wss.once("listening", () => {
                    this.debug(`Server is listening on ${this.url}`);
                    resolve();
                });
                // If an error happens while starting
                this.wss.once("error", (err) => {
                    this.debug(`Server failed to start ${err.stack}`);
                    this.emit("error", err);
                    reject(err);
                });
            });
            this._listening = true;
            this.emit("started", this);
        });
    }
    stop() {
        return __awaiter(this, arguments, void 0, function* (code = 1000, reason = "Server stopping") {
            this.debug("Server is stopping");
            yield new Promise((resolve, reject) => {
                if (this.wss) {
                    // Close any client connections, giving a code and reason
                    for (const ws of this.wss.clients) {
                        ws.close(code, reason);
                    }
                    // Close the server
                    this.wss.close(err => {
                        // Forget about the server
                        delete this.wss;
                        // Reject or resolve the promise
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    });
                    // Terminate any clients still connected, allowing the server to close
                    for (const ws of this.wss.clients) {
                        ws.terminate();
                    }
                }
                else {
                    resolve();
                }
            });
            this.debug("Server was stopped");
            // Resolve the stopped promise
            this._listening = false;
            this.stoppedPromiseHandle.resolve();
        });
    }
    get listening() {
        return this._listening;
    }
    run(fn, context) {
        var _a, _b;
        this.debug("Server started running tests");
        if (!this.wss) {
            if (this.config.autoStart) {
                this.start().then(undefined, err => {
                    this.debug(`Auto-starting failed: ${err.stack}`);
                });
            }
            else {
                throw new Error("Server must be started before run is called");
            }
        }
        if (this.runner) {
            throw new Error("A run is already in progress");
        }
        // this.runner = new Mocha.Runner(this.suite, this.options.delay || false);
        // TODO: Stub this to match the Runner's interface even better
        this.runner = new FakeRunner_1.FakeRunner();
        // Attach event listeners to update stats
        (0, stats_collector_1.createStatsCollector)(this.runner);
        // Bind listeners to the runner, re-emitting events on the server itself
        this.runner.on("end", () => {
            this.emit("end");
        });
        // Set the client options, to be passed to the next running client
        this.clientOptions = {
            grep: this.config.grep,
            invert: this.config.invert,
            timeout: this.config.timeout,
            slow: this.config.slow,
            context: Object.assign(Object.assign({}, this.config.context), context),
        };
        this.debug(this.clientOptions);
        // We need to access the private _reporter field
        const Reporter = this.determineReporterConstructor(this.config.reporter);
        // When constructing the Reporter we need to (unintuitively) pass all options, not the `options.reporterOptions`
        const reporter = new Reporter(this.runner, {
            // alias option name is used in public reporters xunit/tap/progress
            // https://github.com/mochajs/mocha/issues/4153
            reporterOptions: (_a = this.config.reporterOptions) !== null && _a !== void 0 ? _a : this.config.reporterOption,
            reporterOption: (_b = this.config.reporterOption) !== null && _b !== void 0 ? _b : this.config.reporterOptions,
        });
        const done = (failures) => {
            this.debug("Testing is done");
            // If the reporter wants to know when we're done, we will tell it
            // It will call the fn callback for us
            if (reporter.done) {
                reporter.done(failures, fn);
            }
            else if (fn) {
                fn(failures);
            }
        };
        // Attach a listener to the run ending
        this.runner.once(FakeRunner_1.FakeRunner.constants.EVENT_RUN_END, () => {
            const failures = this.runner ? this.runner.failures : 0;
            // Delete the runner to allow another run
            delete this.runner;
            // Get rid of the client options
            delete this.clientOptions;
            // Call any callbacks to signal completion
            done(failures);
        });
        // If we already have a client, tell it to run
        if (this.client && this.client.readyState === ws_1.default.OPEN) {
            this.send({
                action: "run",
                options: this.clientOptions,
            });
        }
        // Return the runner
        return this.runner;
    }
    runAndStop(context) {
        return __awaiter(this, void 0, void 0, function* () {
            let handleError = undefined;
            try {
                // Run the tests
                // TODO: Consider adding a timeout
                const failures = yield new Promise((resolve, reject) => {
                    // Register an error handler and keep a reference to remove it later
                    handleError = reject;
                    this.on("error", handleError);
                    this.run(resolve, context);
                });
                if (failures > 0) {
                    throw new Error(`Tests completed with ${failures} failures`);
                }
            }
            finally {
                // Stop handling errors
                if (handleError) {
                    this.off("error", handleError);
                }
                // Stop the server
                yield this.stop();
            }
        });
    }
    get port() {
        if (this.wss) {
            const { port } = this.wss.address();
            return port;
        }
        else {
            throw new Error("Cannot get port of a server that is not listening");
        }
    }
    get url() {
        if (this.wss) {
            const { address, port, family } = this.wss.address();
            if (family === "IPv6") {
                return `ws://[${address}]:${port}`;
            }
            else {
                return `ws://${address}:${port}`;
            }
        }
        else {
            throw new Error("Cannot get url of a server that is not listening");
        }
    }
    send(msg) {
        if (this.client && this.client.readyState === ws_1.default.OPEN) {
            const data = flatted_1.default.stringify(msg);
            this.client.send(data);
        }
        else {
            throw new Error("No client connected");
        }
    }
    /**
     * @param reporter A constructor or a string containing the name of a builtin reporter or the module name or relative path of one.
     * @returns A constructor for the reporter.
     * @see {Mocha.prototype.reporter}
     */
    determineReporterConstructor(reporter) {
        if (typeof reporter === "function") {
            return reporter;
        }
        else if (typeof reporter === "string") {
            // Try to load a built-in reporter
            if (reporter in builtinReporters) {
                return builtinReporters[reporter];
            }
            // Try to load reporters from process.cwd() and node_modules
            try {
                try {
                    return require(reporter);
                }
                catch (err) {
                    if (err instanceof Error) {
                        const { code } = err;
                        if (code === 'MODULE_NOT_FOUND') {
                            // If the absolute require couldn't find the module, let's try resolving it as a relative path
                            return require(path_1.default.resolve(reporter));
                        }
                    }
                    // Fallback to rethrow
                    throw err;
                }
            }
            catch (err) {
                if (err instanceof Error) {
                    const { code, stack } = err;
                    if (code === 'MODULE_NOT_FOUND') {
                        throw new Error(`Unable to find reporter: '${reporter}'`);
                    }
                    else {
                        throw new Error(`${reporter} reporter blew up with error: ${stack}`);
                    }
                }
                // Fallback to rethrow
                throw err;
            }
        }
        else {
            throw new Error(`Unexpected reporter '${reporter}'`);
        }
    }
}
exports.Server = Server;
Server.DEFAULT_CONFIG = {
    autoStart: false,
    host: "localhost",
    id: "default",
    port: 8090,
    autoRun: false,
    reporter: "spec",
    reporterOptions: {},
    grep: undefined,
    invert: undefined,
    context: undefined,
    timeout: undefined,
    slow: undefined,
};
Server.debugCounter = 0;
//# sourceMappingURL=Server.js.map