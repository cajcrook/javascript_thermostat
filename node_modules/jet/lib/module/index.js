import React, { useEffect, useState, createContext, useContext } from 'react';
import { Text, Platform } from 'react-native';
import parseErrorStack from 'react-native/Libraries/Core/Devtools/parseErrorStack';
import symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';
import { Client } from 'mocha-remote-client';
export const JetContext = /*#__PURE__*/createContext({
  connected: false,
  status: {
    kind: 'waiting'
  },
  config: {}
});
function isExternalFrame({
  file
}) {
  return !file.includes('/jet/') && !file.includes('/mocha-remote/packages/client/dist/') && !file.includes('/mocha-remote-client/dist/');
}
function framesToStack(error, frames) {
  const lines = frames.filter(isExternalFrame).map(({
    methodName,
    column,
    file,
    lineNumber
  }) => {
    return `    at ${methodName} (${file}:${lineNumber}:${column})`;
  });
  return `${error.name}: ${error.message}\n${lines.join('\n')}`;
}
export function JetProvider(props) {
  const [isConnected, setConnected] = useState(false);
  const [currentStatus, setStatus] = useState({
    kind: 'waiting'
  });
  const [currentConfig, setConfig] = useState({});
  useEffect(() => {
    const client = new Client({
      ...props,
      title: props.title ?? `Jet tests on ${Platform.OS}`,
      async transformFailure(_, err) {
        const stack = parseErrorStack(err.stack);
        const symbolicated = await symbolicateStackTrace(stack);
        err.stack = framesToStack(err, symbolicated.stack);
        return err;
      },
      tests(_config) {
        beforeEach('async-pause', () => {
          return new Promise(resolve => setImmediate(resolve));
        });
        after(async () => {
          if (_config.coverage) {
            const coverage = global.__coverage__ ?? {};
            const url = (props.url ?? 'ws://localhost:8090').replace('ws://', 'http://') + '/coverage';
            return fetch(url, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(coverage)
            });
          }
          return Promise.resolve();
        });
        props.tests(_config);
        setConfig(_config);
      }
    }).on('connection', () => {
      setConnected(true);
    }).on('disconnection', () => {
      setConnected(false);
    }).on('running', runner => {
      if (runner.total === 0) {
        setStatus({
          kind: 'ended',
          totalTests: 0,
          failures: 0
        });
      }
      let currentTestIndex = 0;
      runner.on('test', test => {
        setStatus({
          kind: 'running',
          currentTest: test.fullTitle(),
          currentTestIndex: currentTestIndex++,
          totalTests: runner.total,
          failures: runner.failures
        });
      }).on('end', () => {
        setStatus({
          kind: 'ended',
          totalTests: runner.total,
          failures: runner.failures
        });
      });
    });
    return () => {
      client.disconnect();
    };
  }, [setStatus, setConfig, setConnected]);
  return /*#__PURE__*/React.createElement(JetContext.Provider, {
    value: {
      status: currentStatus,
      connected: isConnected,
      config: currentConfig
    }
  }, props.children);
}
export function useJetContext() {
  return useContext(JetContext);
}
function getStatusEmoji(status) {
  if (status.kind === 'running') {
    return '🏃';
  } else if (status.kind === 'waiting') {
    return '⏳';
  } else if (status.kind === 'ended' && status.totalTests === 0) {
    return '🤷';
  } else if (status.kind === 'ended' && status.failures > 0) {
    return '❌';
  } else if (status.kind === 'ended') {
    return '✅';
  } else {
    return null;
  }
}
export function StatusEmoji(props) {
  const {
    status
  } = useJetContext();
  return /*#__PURE__*/React.createElement(Text, props, getStatusEmoji(status));
}
function getStatusMessage(status) {
  if (status.kind === 'running') {
    return `[${status.currentTestIndex + 1} of ${status.totalTests}] ${status.currentTest}`;
  } else if (status.kind === 'waiting') {
    return 'Waiting for Jet to start tests...';
  } else if (status.kind === 'ended' && status.failures > 0) {
    return `${status.failures} tests failed!`;
  } else if (status.kind === 'ended') {
    return 'All tests succeeded!';
  } else {
    return null;
  }
}
export function StatusText(props) {
  const {
    status
  } = useJetContext();
  return /*#__PURE__*/React.createElement(Text, props, getStatusMessage(status));
}
function getConnectionMessage(connected) {
  if (connected) {
    return '🛜 Connected to Jet';
  } else {
    return '🔌 Disconnected from Jet';
  }
}
export function ConnectionText(props) {
  const {
    connected
  } = useJetContext();
  return /*#__PURE__*/React.createElement(Text, props, getConnectionMessage(connected));
}
//# sourceMappingURL=index.js.map