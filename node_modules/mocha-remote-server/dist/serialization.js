"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserialize = exports.createReviver = void 0;
const flatted_1 = __importDefault(require("flatted"));
const debug_1 = require("./debug");
const debug = (0, debug_1.extend)("serialization");
function smellsLikeMochaRemote(line) {
    return line.includes("/mocha-remote");
}
function filterStack(stack) {
    return stack.split("\n").filter(line => !smellsLikeMochaRemote(line)).join("\n");
}
function createReviver() {
    function reviveObject(obj) {
        if (obj.type === "error") {
            if (typeof obj.message === "string" && typeof obj.stack === "string") {
                const err = new Error(obj.message);
                err.stack = filterStack(obj.stack);
                return err;
            }
            else {
                throw new Error("Expected Error to have message and stack");
            }
        }
        else {
            // Turn $$ properties into functions
            for (const propertyName of Object.keys(obj).filter(name => name.startsWith("$$"))) {
                const result = obj[propertyName];
                obj[propertyName.substring(2)] = () => result;
            }
            return obj;
        }
    }
    return function reviver(key, value) {
        debug(`Reviving %s`, value);
        if (typeof value === "object" && value !== null) {
            return reviveObject(value);
        }
        else {
            return value;
        }
    };
}
exports.createReviver = createReviver;
function deserialize(text, reviver = createReviver()) {
    debug("Deserializing %s", text);
    return flatted_1.default.parse(text, reviver);
}
exports.deserialize = deserialize;
//# sourceMappingURL=serialization.js.map